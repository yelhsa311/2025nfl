<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NFL Picks – Overall Standings</title>
  <style>
    :root { --gap: 14px; }
    html,body{font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji"; background:#0b1220; color:#e6edf3;}
    .wrap{max-width: 1100px; margin: 36px auto; padding: 0 16px;}
    h1{font-size: clamp(22px, 2.8vw, 32px); margin: 0 0 12px}
    .meta{opacity:.8; font-size: 13px; margin-bottom: 22px}
    .card{background:#0f172a; border:1px solid #1f2937; border-radius:16px; box-shadow: 0 10px 22px rgba(0,0,0,.25); padding:18px}
    .row{display:flex; gap:var(--gap); flex-wrap:wrap; align-items:center}
    .row > *{flex:1}
    .row .right{flex:0 0 auto}
    button{background:#1f6feb; color:white; border:0; padding:10px 14px; border-radius:12px; cursor:pointer; font-weight:600}
    button:disabled{opacity:.6; cursor:progress}
    table{width:100%; border-collapse: collapse; margin-top:10px}
    th,td{padding:10px 12px; border-bottom:1px solid #1f2937; text-align:left}
    th{font-size:12px; letter-spacing:.08em; text-transform:uppercase; opacity:.8}
    tbody tr:hover{background:#0b132a}
    .rank{font-variant-numeric: tabular-nums; width:60px}
    .num{font-variant-numeric: tabular-nums}
    .pill{background:#111827; border:1px solid #1f2937; padding: 3px 8px; border-radius:999px; font-size:12px}
    .footer{opacity:.7; font-size:12px; margin-top:14px}
    .hidden{display:none}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Overall Standings</h1>
    <div class="meta">Live view of totals across all weeks. Auto-uses cached totals if present; otherwise computes from picks on the fly.</div>

    <div class="card">
      <div class="row">
        <div>
          <div><span class="pill" id="build">BUILD: unknown</span></div>
        </div>
        <div class="right">
          <button id="refreshBtn">Recalculate Now</button>
        </div>
      </div>

      <table id="standings">
        <thead>
          <tr>
            <th class="rank">Rank</th>
            <th>Player</th>
            <th class="num">Correct</th>
            <th class="num">Points</th>
            <th class="num">Weeks</th>
          </tr>
        </thead>
        <tbody id="tbody">
          <tr><td colspan="5">Loading…</td></tr>
        </tbody>
      </table>

      <div class="footer" id="sourceHint">Source: <span id="sourceLabel">detecting…</span></div>
    </div>
  </div>
  
 
  <!-- Firebase (v10+ modular) via ESM CDN. If you bundle, replace with your imports. -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
    import { getFirestore, collection, collectionGroup, getDocs, onSnapshot, query, orderBy, where, doc, getDoc } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";

    // ─── Configure YOUR project ────────────────────────────────────────────────
    // Replace with your actual config or import from a shared config file.
    const firebaseConfig = {
      apiKey: "AIzaSyCBgBR2n4e5ObgQOpRNRQQtZ7AhKLBr080",
      authDomain: "nfl-picks-b83c2.firebaseapp.com",
      projectId: "nfl-picks-b83c2",
      storageBucket: "nfl-picks-b83c2.firebasestorage.app",
      messagingSenderId: "802058909501",
      appId: "1:802058909501:web:bb935c188891934de07754",
      measurementId: "G-MSJHYZ4VG2"
    };
    window.BUILD_ID = "overall-2025-09-28-22:25"; // optional sanity tag
    const BUILD_ID = (window.BUILD_ID ?? new Date().toISOString());
    document.getElementById('build').textContent = `BUILD: ${BUILD_ID}`;

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    const $tbody = document.getElementById('tbody');
    const $sourceLabel = document.getElementById('sourceLabel');
    const $refreshBtn = document.getElementById('refreshBtn');

    const STATE = { last: [] };

    function render(rows){
      $tbody.innerHTML = '';
      if (!rows.length){
        $tbody.innerHTML = '<tr><td colspan="5">No data</td></tr>';
        return;
      }
      rows.forEach((r, i)=>{
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td class="rank">${i+1}</td>
          <td>${escapeHtml(r.name ?? r.userName ?? r.userId ?? 'Unknown')}</td>
          <td class="num">${r.correct ?? 0}</td>
          <td class="num">${(r.points ?? r.correct ?? 0)}</td>
          <td class="num">${r.weeks ?? '-'}</td>
        `;
        $tbody.appendChild(tr);
      });
    }

    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[m]));
    }

    // Try 1: Listen to a cached totals collection if it exists (fast + live)
    async function tryLiveCachedTotals(){
      try{
        const ref = collection(db, 'overallTotals');
        // If collection exists, onSnapshot will stream documents.
        const unsub = onSnapshot(query(ref, orderBy('points','desc')), snap => {
          const rows = snap.docs.map(d=>({ id:d.id, ...d.data() }));
          if (rows.length){
            $sourceLabel.textContent = 'overallTotals (live)';
            STATE.last = normalizeRows(rows);
            render(STATE.last);
          }
        }, err => console.warn('overallTotals snapshot err', err));
        // Also do a one-time check to confirm existence
        const check = await getDocs(ref);
        if (!check.empty){ return unsub; }
        unsub();
      }catch(e){ /* collection may not exist yet */ }
      return null;
    }

    function normalizeRows(rows){
      return rows.map(r=>({
        userId: r.userId ?? r.id,
        name: r.name ?? r.userName ?? r.displayName ?? r.id,
        correct: Number(r.correct ?? r.wins ?? 0),
        points: Number(r.points ?? r.correct ?? 0),
        weeks: r.weeks ?? r.totalWeeks
      })).sort((a,b)=> (b.points - a.points) || (b.correct - a.correct) || String(a.name).localeCompare(String(b.name)));
    }

    // Try 2: Compute from picks (works whether picks are in a top-level collection
    // or as user subcollections via collectionGroup("picks")).
async function computeFromPicks(){
  $refreshBtn.disabled = true;
  $refreshBtn.textContent = 'Recalculating…';
  try {
    const byUser = new Map<string, {userId:string, name?:string, correct:number, points:number, _weeks:Set<string>}>();

    // helper to add a single pick-ish record
    const add = (uid:string, name:string|undefined, week:string|number|undefined, correct:boolean|undefined, pts:number|undefined) => {
      if (!byUser.has(uid)) byUser.set(uid, { userId: uid, name, correct: 0, points: 0, _weeks: new Set() });
      const agg = byUser.get(uid)!;
      if (name && !agg.name) agg.name = name;
      if (correct) agg.correct += 1;
      agg.points += Number(pts ?? (correct ? 1 : 0));
      if (week !== undefined && week !== null) agg._weeks.add(String(week));
    };

    let used = '';

    // (A) Try flat top-level /picks docs (some apps store each pick here)
    try {
      const top = await getDocs(collection(db, 'picks'));
      if (!top.empty) {
        used = '/picks (flat)';
        for (const ds of top.docs) {
          const d:any = ds.data();
          const uid = d.userId ?? d.uid ?? ds.id;
          const name = d.userName ?? d.name;
          const week = d.week ?? d.weekNumber;
          const correct = d.correct === true || d.isCorrect === true || d.result === 'win';
          const pts = d.points;
          add(uid, name, week, correct, pts);
        }
      }
    } catch {/* ignore and fall through */}

    // (B) If nothing yet, try /picks/{uid}/weeks/{week}/picks
    if (!byUser.size) {
      try {
        used = '/picks/{uid}/weeks/{week}/picks';
        const usersSnap = await getDocs(collection(db, 'picks'));
        for (const u of usersSnap.docs) {
          const uid = u.id;
          const weeksRef = collection(u.ref, 'weeks');
          const weeksSnap = await getDocs(weeksRef);
          for (const w of weeksSnap.docs) {
            const weekId = w.id;
            try {
              const picksRef = collection(w.ref, 'picks'); // subcollection holding each game pick
              const picksSnap = await getDocs(picksRef);
              if (!picksSnap.empty) {
                for (const p of picksSnap.docs) {
                  const d:any = p.data();
                  const name = d.userName ?? d.name;
                  const correct = d.correct === true || d.isCorrect === true || d.result === 'win';
                  const pts = d.points;
                  add(uid, name, weekId, correct, pts);
                }
              }
            } catch {/* may not exist; fall back to (C) */}
          }
        }
      } catch {/* ignore */}
    }

    // (C) If still nothing, treat each /weeks/{week} doc AS the “pick” (fields on the week doc)
    if (!byUser.size) {
      try {
        used = '/picks/{uid}/weeks/{week} (docs hold results)';
        const usersSnap = await getDocs(collection(db, 'picks'));
        for (const u of usersSnap.docs) {
          const uid = u.id;
          const weeksRef = collection(u.ref, 'weeks');
          const weeksSnap = await getDocs(weeksRef);
          for (const w of weeksSnap.docs) {
            const d:any = w.data();
            const name = d.userName ?? d.name;
            // try common field names; adjust to your schema if different
            const correct = d.correct === true || d.isCorrect === true || d.result === 'win';
            const pts = d.points ?? d.score ?? d.total ?? undefined;
            add(uid, name, w.id, correct, pts);
          }
        }
      } catch {/* ignore */}
    }

    if (!byUser.size) {
      $sourceLabel.textContent = 'No data found';
      $tbody.innerHTML = '<tr><td colspan="5">No picks detected. Check collection names/fields.</td></tr>';
      return;
    }

    // Optional: look up display names from /users/{uid}
    const results = Array.from(byUser.values());
    for (const r of results) {
      if (!r.name) {
        try {
          const u = await getDoc(doc(db, 'users', r.userId));
          if (u.exists()) r.name = (u.data() as any).displayName ?? (u.data() as any).name ?? r.userId;
        } catch {/* ignore */}
      }
      (r as any).weeks = r._weeks.size; delete (r as any)._weeks;
    }

    // sort + render
    const rows = results
      .map(r => ({ ...r, points: Number(r.points || 0), correct: Number(r.correct || 0) }))
      .sort((a,b)=> (b.points - a.points) || (b.correct - a.correct) || String(a.name||a.userId).localeCompare(String(b.name||b.userId)));

    $sourceLabel.textContent = used + ' (computed)';
    render(rows);
  } catch (e) {
    console.error(e);
    $tbody.innerHTML = `<tr><td colspan="5">Error: ${e}</td></tr>`;
  } finally {
    $refreshBtn.disabled = false;
    $refreshBtn.textContent = 'Recalculate Now';
  }
}


    // Init
    (async()=>{
      const unsub = await tryLiveCachedTotals();
      if (!unsub){
        await computeFromPicks();
      }
    })();

    $refreshBtn.addEventListener('click', computeFromPicks);
  </script>
</body>
</html>
