<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Family NFL Picks (v2.2)</title>
<style>
  :root{
    --bg:#0f1115; --fg:#e7e7e7; --muted:#9aa0a6; --card:#171a21; --accent:#6ea8ff; --bad:#ff6b6b; --border:#252a33;

    /* New, clearer result colors */
    --final-border:#8b5cf6;     /* purple for FINAL */
    --final-bg:rgba(139,92,246,.12);
    --final-chip-bg:#2b2340;
    --final-chip-fg:#d6bcff;
    --final-chip-border:#6d41f1;

    --correct-border:#22c55e;   /* green for CORRECT */
    --correct-bg:rgba(34,197,94,.12);
    --correct-chip-bg:#0f2919;
    --correct-chip-fg:#86f5b2;
    --correct-chip-border:#1ea45e;

    --wrong-border:#ef4444;     /* red for WRONG */
    --wrong-bg:rgba(239,68,68,.10);
    --wrong-chip-bg:#2a1111;
    --wrong-chip-fg:#ff9a9a;
    --wrong-chip-border:#8a2b2b;
  }

  body{margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:var(--bg);color:var(--fg)}
  .wrap{max-width:960px;margin:0 auto;padding:12px}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .card{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:12px;margin-top:12px}
  button,input,select{border:1px solid var(--border);background:var(--card);color:var(--fg);padding:10px;border-radius:10px}
  button.primary{outline:2px solid var(--accent)}
  .grid{display:grid;grid-template-columns:1fr auto 1fr;gap:8px;align-items:center}
  .match{padding:10px;border:1px dashed var(--border);border-radius:10px}

  .team{
    position:relative;
    padding:8px 10px;
    border:1px solid var(--border);
    border-radius:10px;
    text-align:center;
    cursor:pointer;
    transition:all .15s ease;
    background:var(--card);
    color:var(--fg);
  }

  /* Standings table cues (unchanged) */
  #standings table{ border-collapse:separate; border-spacing:0; overflow:hidden; }
  #standings tbody tr.me { outline:2px solid #6ea8ff; outline-offset:-2px; background:rgba(110,168,255,.06); }
  #standings tbody tr.leader { background:rgba(34,197,94,.08); }
  #standings tbody tr.sub500 { opacity:.9; }
  #standings tbody tr.perfect { background:rgba(34,197,94,.14); }

  .badge-chip{
    display:inline-block; font-size:11px; padding:2px 6px; border-radius:999px;
    border:1px solid var(--border); background:#12151c; margin-left:6px;
  }
  .badge-chip.leader { color:#5be087; border-color:#1b7f48; }
  .badge-chip.me     { color:#9cc7ff; border-color:#2e4370; }
  .badge-chip.perfect{ color:#86f5b2; border-color:#1ea45e; }
  .badge-chip.sub500 { color:#ff9a9a; border-color:#8a2b2b; }

  /* User's pick (neutral highlight for "your selection") */
  .team.winner{
    border-color:#f6c000;
    box-shadow:0 0 4px 1px rgba(246,192,0,.25) inset;
  }
  .team.winner::before{
    content:"Your Pick";
    position:absolute;
    top:-10px; left:10px;
    font-size:10px;
    background:#1f1a07; color:#ffd75a;
    border:1px solid #8f6b00;
    border-radius:6px;
    padding:1px 4px;
  }

  /* FINAL result (purple) */
  .team.result{
    border-color:var(--final-border);
    background:var(--final-bg);
    box-shadow:0 0 0 1px rgba(139,92,246,.35) inset;
  }
  .team.result::after{
    content:"Winner";
    position:absolute;
    top:-10px; right:10px;
    font-size:10px;
    background:var(--final-chip-bg); color:var(--final-chip-fg);
    border:1px solid var(--final-chip-border);
    border-radius:6px;
    padding:1px 4px;
  }

  /* Both picked and winner (CORRECT ‚Üí green) */
  .team.winner.result{
    border-color:var(--correct-border);
    background:var(--correct-bg);
    box-shadow:0 0 4px 1px rgba(34,197,94,.4) inset, 0 0 10px rgba(34,197,94,.25);
  }
  .team.winner.result::before{
    content:"üèÜ Correct";
    background:var(--correct-chip-bg);
    color:var(--correct-chip-fg);
    border-color:var(--correct-chip-border);
  }

  /* Game finalized but wrong pick (WRONG ‚Üí red) */
  .match .team.winner:not(.result):has(+ .team.result),
  .match .team.winner:not(.result):has(~ .team.result){
    opacity:.85;
    border-color:var(--wrong-border);
    background:var(--wrong-bg);
    box-shadow:0 0 4px 1px rgba(239,68,68,.25) inset;
  }
  .match .team.winner:not(.result):has(+ .team.result)::before,
  .match .team.winner:not(.result):has(~ .team.result)::before{
    content:"‚úó Wrong";
    background:var(--wrong-chip-bg); color:var(--wrong-chip-fg); border-color:var(--wrong-chip-border);
  }

  /* Disabled */
  .team.disabled{opacity:.5;pointer-events:none;}

  .bar{display:flex;justify-content:space-between;align-items:center}
  .muted{color:var(--muted)}
  .danger{color:var(--bad)}
  .pill{padding:6px 10px;border:1px solid var(--border);border-radius:999px}
  .lock{padding:4px 8px;border-radius:999px;border:1px solid var(--border)}
  .disabled{opacity:.6;pointer-events:none}
  h2.day{margin:16px 0 8px}
  .toast{position:fixed;bottom:16px;left:50%;transform:translateX(-50%);background:#000a;color:#fff;padding:10px 14px;border-radius:999px;opacity:0;transition:opacity .2s;z-index:1000}
  .toast.show{opacity:1}
  .badge{font-size:12px;border:1px solid var(--border);border-radius:6px;padding:2px 6px;background:var(--card);color:var(--fg);cursor:pointer}
  .admin-chip{font-size:11px;opacity:.85}
  .version-pill{background:#0d1428;color:#9cc7ff;border-color:#2d3a55;font-size:12px;}
  table{width:100%;border-collapse:collapse;margin-top:8px}
  th,td{border:1px solid var(--border);padding:8px;text-align:left}
  th{background:#12151c}
</style>
</head>
<body>
<div class="wrap">
  <div class="bar">
    <div class="row" style="align-items:center; gap:8px">
      <h1 style="margin:0">Family NFL Picks</h1>
      <span class="pill version-pill">v2.2</span>
    </div>
    <a href="overall.html" class="pill">View Overall Leaderboard ‚Üí</a>
    <!-- Admin Grid link -->
    <a href="admin-grid.html" class="admin-only" style="margin-left:10px;">üóÇ Admin Grid</a>
    <div id="userBox" class="row"></div>
  </div>

  <!-- Auth -->
  <div id="auth" class="card">
    <div class="row">
      <input id="email" type="email" placeholder="Email" />
      <input id="pass" type="password" placeholder="Password" />
      <button id="signInBtn" class="primary">Sign in</button>
      <button id="registerBtn">Register</button>
    </div>
    <div class="muted" style="margin-top:6px">Only invited family should register.</div>
  </div>

  <!-- App -->
  <div id="app" class="card" style="display:none">
    <div class="row">
      <label>Week:</label>
      <select id="weekSelect"></select>
      <span id="lockBadge" class="lock muted">Open</span>
      <span class="pill" id="adminBadge" style="display:none">ADMIN</span>
      <button id="finalizeBtn" class="pill" style="display:none">Finalize Week</button>
    </div>

    <!-- Legend updated to match new colors -->
    <div class="legend" style="margin-top:8px;font-size:12px;opacity:.85">
      <span style="color:#ffd75a">Your Pick</span> ¬∑
      <span style="color:#86f5b2">üèÜ Correct</span> ¬∑
      <span style="color:#ff9a9a">‚úó Wrong</span> ¬∑
      <span style="color:#c7b6ff">Winner (purple)</span>
    </div>

    <div id="games" class="card" style="margin-top:8px">
      <div class="bar"><strong>Games</strong><span class="muted">Pick winners before kickoff</span></div>
      <div class="muted" id="noGames" style="display:none">No games yet for this week.</div>
      <div id="gameList"></div>
    </div>

    <div id="standings" class="card" style="margin-top:8px">
      <div class="bar">
        <strong>Standings ‚Äî Week <span id="wkNum">1</span></strong>
        <div id="publishWrap" style="display:none" class="row">
          <button id="recalcBtn" class="badge">Recalculate</button>
          <button id="publishBtn" class="badge">Publish</button>
        </div>
      </div>
      <div id="standingsBody">
        <div class="muted">Standings will appear once there are winners and picks.</div>
      </div>
    </div>

    <div class="card">
      <div class="bar">
        <div class="muted">Your picks autosave</div>
      </div>
    </div>
  </div>

  <div class="toast" id="toast">Saved!</div>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
  import {
    getAuth, onAuthStateChanged, signInWithEmailAndPassword,
    createUserWithEmailAndPassword, signOut,
    setPersistence, browserLocalPersistence
  } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js";
  import {
    initializeFirestore, getFirestore, doc, setDoc, getDoc, getDocs, Timestamp,
    onSnapshot, collection, addDoc, query, orderBy, collectionGroup, deleteDoc
  } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";

  // --- Firebase config ---
  const firebaseConfig = {
    apiKey: "AIzaSyCBgBR2n4e5ObgQOpRNRQQtZ7AhKLBr080",
    authDomain: "nfl-picks-b83c2.firebaseapp.com",
    projectId: "nfl-picks-b83c2",
    storageBucket: "nfl-picks-b83c2.appspot.com",
    messagingSenderId: "802058909501",
    appId: "1:802058909501:web:bb935c188891934de07754",
    measurementId: "G-MSJHYZ4VG2"
  };

  // --- Init ---
  const app = initializeApp(firebaseConfig);
  initializeFirestore(app, { experimentalAutoDetectLongPolling: true, useFetchStreams: false });
  const auth = getAuth(app);
  const db = getFirestore(app);

  // Persist login across tabs/reloads
  await setPersistence(auth, browserLocalPersistence);

  // --- Admin UID(s) ---
  window.ADMIN_UIDS = ["j8D0AzlAgmTHSaDcBHwQbpMT9Is1"]; // your admin account

  // --- Helper: ensure /publicUsers/{uid} has emailLower for UID resolution ---
  async function upsertPublicUser(user) {
    const emailLower = (user.email || "").toLowerCase();
    if (!emailLower) return; // skip anonymous / no-email identities
    await setDoc(doc(db, "publicUsers", user.uid), { emailLower }, { merge: true });
  }

  // --- Optional: block anonymous sessions on admin-only pages ---
  function handleAnonymousOnAdmin(user) {
    // if this page is admin-only (e.g., window.IS_ADMIN_PAGE set in the HTML),
    // kick out anonymous users to prevent ‚Äúnew UID each time‚Äù issues
    if (window.IS_ADMIN_PAGE && user && user.isAnonymous) {
      alert("Please sign in with your real account to use admin tools.");
      signOut(auth).finally(() => {
        location.href = "/index.html"; // change if your login page differs
      });
      return true; // handled
    }
    return false;
  }

  // --- Auth state ---
  onAuthStateChanged(auth, async (user) => {
    if (!user) return;                 // not signed in yet
    if (handleAnonymousOnAdmin(user)) return;  // block anon on admin pages
    await upsertPublicUser(user);      // ensure publicUsers mapping exists
    // (optional) expose auth/db for debugging
    window._auth = auth; window._db = db;
  });

  // --- Helpers ---
  const el = s => document.querySelector(s);
  const toast = (msg="Saved!") => { const t=el("#toast"); t.textContent=msg; t.classList.add("show"); setTimeout(()=>t.classList.remove("show"),900); };

  const state = { user:null, isAdmin:false, weekId:"2025-Week-01", lock:false, picks:{}, games:[], lockAt:null };
  let autoLockApplied = false;

  function getEarliestKickoffMs(games){
    let min = null;
    for (const g of games || []){
      const ms = typeof g.kickoffTs === "number" ? g.kickoffTs
               : (g.kickoff ? Date.parse(g.kickoff) : null);
      if (Number.isFinite(ms)) min = (min==null) ? ms : Math.min(min, ms);
    }
    return min;
  }

  // 30 minutes before first kickoff
  function computeAutoLockAtMs(){
    const first = getEarliestKickoffMs(state.games);
    if (first == null) return null;
    return first - 30 * 60 * 1000;
  }

  // true if picks are locked for non-admins
  function isWriteLocked(){
    const now = Date.now();
    const autoLock = state.lockAt ? (now >= state.lockAt) : false;
    return state.lock || autoLock;
  }

  function updateLockUi(autoLocked = false){
    let label = "Open";
    if (state.lock) label = "Finalized";
    else if (state.lockAt && !autoLocked) label = "Locks " + new Date(state.lockAt).toLocaleTimeString([], { hour: "numeric", minute: "2-digit" });
    else if (autoLocked) label = "Locked (kickoff)";

    el("#lockBadge").textContent = label;
    el("#lockBadge").className   = "lock " + ((state.lock || autoLocked) ? "danger" : "muted");

    const finalizeBtn = el("#finalizeBtn");
    if (finalizeBtn){
      finalizeBtn.textContent = state.lock ? "Unlock Week" : "Finalize Week";
      finalizeBtn.title = state.lock ? "Re-open picks until the auto lock" : "Lock picks for everyone";
      finalizeBtn.style.display = state.isAdmin ? "" : "none";
    }
  }

  // Admin finalize button with confirmation
  el("#finalizeBtn")?.addEventListener("click", async () => {
    if (!state.isAdmin){
      return;
    }

    // Guard against rare cases where the lock listener hasn't initialized yet
    // (e.g., clicking immediately after sign-in). Build the ref on-demand.
    const lockRef = currentLockRef || doc(db, "weeks", state.weekId, "meta", "lock");
    currentLockRef = lockRef;
    const promptMsg = state.lock
      ? "Unlock this week so users can keep making changes until it auto-locks 30 minutes before kickoff?"
      : "Finalize this week and lock all picks?";
    const confirmed = window.confirm(promptMsg);
    // When locked, confirmation means unlock; when open, confirmation locks.
    const desiredLock = state.lock ? (confirmed ? false : state.lock) : confirmed;
    const lockPayload = {
      locked: desiredLock,
      finalized: desiredLock,
      lock: desiredLock,
      final: desiredLock,
      isFinal: desiredLock
    };

    try {
      await setDoc(lockRef, lockPayload, { merge:true });

      // Verify the lock saved so the UI stays in sync even if the listener is delayed
      const snap = await getDoc(lockRef);
      const saved = snap.exists() ? snap.data() : lockPayload;
      const persistedLock = [saved.locked, saved.finalized, saved.final, saved.isFinal, saved.lock].some(v => v === true);

      state.lock = persistedLock || desiredLock;
      updateLockUi(state.lockAt ? Date.now() >= state.lockAt : false);
      renderGames();
      toast(state.lock ? "Week finalized. Picks are locked." : "Week unlocked.");
    } catch (err) {
      console.error("finalize toggle", err);
      alert("Unable to save the lock state. Please try again.");
    }
  });

  // --- Auth UI ---
  el("#signInBtn").onclick = async () => {
    const email = el("#email").value.trim();
    const pass  = el("#pass").value;
    try { await signInWithEmailAndPassword(auth, email, pass); } catch(e){ alert(e.message); }
  };
  el("#registerBtn").onclick = async () => {
    const email = el("#email").value.trim();
    const pass  = el("#pass").value;
    try { await createUserWithEmailAndPassword(auth, email, pass); } catch(e){ alert(e.message); }
  };

  onAuthStateChanged(auth, async (user) => {
    state.user = user || null;

    if (!user){
      el("#auth").style.display="block";
      el("#app").style.display ="none";
      el("#userBox").innerHTML = "";
      return;
    }

    el("#userBox").innerHTML = `<span class="pill">${user.email}</span> <button id="signOutBtn">Sign out</button>`;
    el("#signOutBtn").onclick = async () => { try { await signOut(auth); } finally { location.reload(); } };

    state.isAdmin = (window.ADMIN_UIDS||[]).includes(user.uid);
    el("#adminBadge").style.display    = state.isAdmin ? "" : "none";
    el("#finalizeBtn").style.display  = state.isAdmin ? "" : "none";

    // Show or hide any .admin-only links (like Admin Grid)
    document.querySelectorAll(".admin-only").forEach(n => {
      n.style.display = state.isAdmin ? "" : "none";
    });

    el("#auth").style.display="none";
    el("#app").style.display ="block";

    await setupWeeks();
    await subscribeWeek();
    wireStandingsButtons();
  });

  async function setupWeeks(){
    const sel = el("#weekSelect"); sel.innerHTML="";
    for (let i=1;i<=18;i++){
      const id = `2025-Week-${String(i).padStart(2,"0")}`;
      const o = document.createElement("option");
      o.value=id; o.textContent=`Week ${i}`;
      sel.appendChild(o);
    }
    const remembered = localStorage.getItem("lastWeekId");
    state.weekId = remembered || state.weekId;
    sel.value = state.weekId;

    sel.onchange = () => {
      state.weekId = sel.value;
      localStorage.setItem("lastWeekId", state.weekId);
      subscribeWeek();
    };
  }

  let unsubGames=null, unsubLock=null, unsubMyPicks=null;
  let currentLockRef = null;

  async function subscribeWeek(){
    unsubGames?.(); unsubLock?.(); unsubMyPicks?.();
    autoLockApplied = false;

    // Lock meta
    const lockRef = doc(db, "weeks", state.weekId, "meta", "lock");
    currentLockRef = lockRef;
    unsubLock = onSnapshot(lockRef, s => {
      const d = s.exists() ? s.data() : {};
      const metaLock = [d.locked, d.finalized, d.final, d.isFinal, d.lock].some(v => v === true);
      state.lockAt = (d.lockAt && d.lockAt.seconds) ? (d.lockAt.seconds * 1000) : null;
      // Badge text
      const now = Date.now();
      const autoLocked = state.lockAt ? now >= state.lockAt : false;
      state.lock = !!(metaLock || autoLocked);
      if (autoLocked && !state.lock && !autoLockApplied){
        autoLockApplied = true;
        setDoc(lockRef, { locked: true }, { merge:true }).catch(console.error);
      }
      updateLockUi(autoLocked);
      renderGames();

      // Live countdown timer
      clearInterval(window.__lockTicker);
      if (state.lock || !state.lockAt) return;
      function tick(){
        const now = Date.now();
        const diff = state.lockAt - now;
        if (diff <= 0){
          el("#lockBadge").textContent = "Locked (kickoff)";
          el("#lockBadge").className   = "lock danger";
          clearInterval(window.__lockTicker);
          renderGames();
          return;
        }
        const m = Math.floor(diff / 60000);
        const s = Math.floor((diff % 60000) / 1000);
        el("#lockBadge").textContent = `Locks in ${m}m ${String(s).padStart(2, "0")}s`;
        el("#lockBadge").className   = "lock muted";
      }
      tick();
      window.__lockTicker = setInterval(tick, 1000);
    }, e => console.error("lock listener", e));

    // Games (ordered by createdAt; UI sorts by kickoffTs)
    const gamesCol = collection(db, "weeks", state.weekId, "games");
    unsubGames = onSnapshot(query(gamesCol, orderBy("createdAt","asc")), snap => {
      state.games = []; snap.forEach(d => state.games.push({ id:d.id, ...d.data() }));
      el("#noGames").style.display = state.games.length ? "none" : "";
      renderGames();

      // Auto-sync lockAt to 30 minutes before earliest kickoff
      const ms = computeAutoLockAtMs();
      const desiredLockAtMs = ms || null;
      const currentLockAtMs = state.lockAt;
      if (desiredLockAtMs !== currentLockAtMs){
        const lockAtPayload = desiredLockAtMs ? { lockAt: Timestamp.fromMillis(desiredLockAtMs) } : { lockAt: null };
        setDoc(lockRef, lockAtPayload, { merge:true }).catch(console.error);
      }
    }, e => console.error("games listener", e));

    // My picks
    const picksRef = doc(db, "picks", state.user.uid, "weeks", state.weekId);
    unsubMyPicks = onSnapshot(picksRef, snap => {
      state.picks = snap.exists() ? (snap.data().picks||{}) : {};
      renderGames();
    }, e => console.error("picks listener", e));

  }

  // --- Rendering ---
  function renderGames(){
    const list = el("#gameList"); list.innerHTML="";

    const orderDays = ["Thursday","Friday","Saturday","Sunday","Monday"];
    const mapDay = d => {
      const x = String(d||"").trim().toLowerCase();
      const m = { thursday:"Thursday", friday:"Friday", saturday:"Saturday", sunday:"Sunday", monday:"Monday" };
      return m[x] || "Other";
    };

    const groups = Object.fromEntries([...orderDays, "Other"].map(d => [d, []]));
    (state.games||[]).forEach(g => { (groups[mapDay(g.day)]||groups.Other).push(g); });

    const readKick = g => {
      if (typeof g.kickoffTs === "number") return g.kickoffTs;
      if (g.kickoff){ const t = Date.parse(g.kickoff); return Number.isFinite(t) ? t : null; }
      return null;
    };
    const sortByKick = (a,b) => {
      const at=readKick(a), bt=readKick(b);
      if (at!=null && bt!=null && at!==bt) return at-bt;
      if (at!=null && bt==null) return -1; if (at==null && bt!=null) return 1;
      const ac=a.createdAt||0, bc=b.createdAt||0; return ac-bc;
    };
    const fmt = ms => new Date(ms).toLocaleTimeString([], { hour:"numeric", minute:"2-digit" });

    const rowFor = g => {
      const row  = document.createElement("div"); row.className="match grid";
      const home = document.createElement("button"); home.className="team"; home.textContent=g.home;
      const vs   = document.createElement("div");   vs.style.textAlign="center";
      const away = document.createElement("button"); away.className="team"; away.textContent=g.away;

      const t = readKick(g);
      vs.innerHTML = t ? `<span class="muted">vs<br><small>${fmt(t)}</small></span>` : `<span class="muted">vs</span>`;

      // user's pick highlight
      if ((state.picks||{})[g.id]==="home") home.classList.add("winner");
      if ((state.picks||{})[g.id]==="away") away.classList.add("winner");

      // game result highlight (admin-set) ‚Üí final is purple, correct stays green
      if (g.winner === "home") home.classList.add("result");
      if (g.winner === "away") away.classList.add("result");

      // lock picks for non-admin when finalized
      if (!state.isAdmin && isWriteLocked()){ home.classList.add("disabled"); away.classList.add("disabled"); }

      home.onclick = () => choose(g.id, "home");
      away.onclick = () => choose(g.id, "away");

      // Admin winner controls
      if (state.isAdmin){
        const adminRow = document.createElement("div");
        adminRow.className = "muted admin-chip";
        adminRow.style.marginTop = "6px";
        adminRow.innerHTML = `
          <button class="badge" data-act="win-home">Set Home as Winner</button>
          <button class="badge" data-act="win-away">Set Away as Winner</button>
          <button class="badge" data-act="clear">Clear</button>
        `;
        vs.appendChild(adminRow);
        adminRow.addEventListener("click", (e) => {
          const btn = e.target.closest("button"); if (!btn) return;
          const act = btn.getAttribute("data-act");
          if (act === "win-home")  setWinner(g.id, "home");
          if (act === "win-away")  setWinner(g.id, "away");
          if (act === "clear")     setWinner(g.id, null);
        });
      }

      home.setAttribute("title", home.getAttribute("aria-label") || g.home);
      away.setAttribute("title", away.getAttribute("aria-label") || g.away);

      row.appendChild(home); row.appendChild(vs); row.appendChild(away);
      return row;
    };

    let any=false;
    for (const d of orderDays){
      const arr = groups[d];
      if (!arr.length) continue;
      arr.sort(sortByKick);
      const h = document.createElement("h2"); h.className="day"; h.textContent = d;
      list.appendChild(h);
      arr.forEach(g => list.appendChild(rowFor(g)));
      any = true;
    }
    if (groups.Other.length){
      groups.Other.sort(sortByKick);
      const h = document.createElement("h2"); h.className="day"; h.textContent = "Other";
      list.appendChild(h);
      groups.Other.forEach(g => list.appendChild(rowFor(g)));
      any = true;
    }

    el("#noGames").style.display = any ? "none" : "";

    const wk = Number(state.weekId.split("-").pop());
    el("#wkNum").textContent = String(wk);

    computeWeekStandings();
  }

  // --- Actions ---
  async function choose(gameId, side){
    if (!state.isAdmin && isWriteLocked()) return;
    state.picks[gameId] = side;
    const ref = doc(db, "picks", state.user.uid, "weeks", state.weekId);
    await setDoc(ref, { weekId: state.weekId, picks: state.picks, updatedAt: Date.now(), email: state.user.email }, { merge:true });
    toast();
    renderGames();
  }

  async function setWinner(gameId, side /* "home" | "away" | null */){
    if (!state.isAdmin) return;
    const ref = doc(db, "weeks", state.weekId, "games", gameId);
    await setDoc(ref, { winner: side ?? null }, { merge:true });
    toast(side ? `Winner set: ${side}` : "Winner cleared");
    computeWeekStandings();
  }

  async function saveGame(){
    if (!state.isAdmin) return;
    const dayInput  = el("#gameDay");
    const homeInput = el("#homeTeam");
    const awayInput = el("#awayTeam");
    if (!dayInput || !homeInput || !awayInput){
      console.warn("Game editor not available.");
      return;
    }

    const day  = (dayInput.value || "Sunday").trim();
    const home = homeInput.value.trim();
    const away = awayInput.value.trim();
    const raw  = el("#kickoff")?.value || ""; // yyyy-mm-ddThh:mm
    const kickoffTs = raw ? Date.parse(raw) : null;
    if (!home || !away) return alert("Enter both team names.");
    await addDoc(collection(db, "weeks", state.weekId, "games"), {
      day, home, away, createdAt: Date.now(), ...(kickoffTs ? { kickoffTs } : {})
    });
    homeInput.value=""; awayInput.value="";
    const kickoffInput = el("#kickoff");
    if (kickoffInput) kickoffInput.value="";
    toast("Game added");
  }

  async function clearGames(){
    if (!state.isAdmin){ console.warn("Admin only"); return; }
    const colRef = collection(db, "weeks", state.weekId, "games");
    const snap = await getDocs(colRef);
    let n=0; for (const d of snap.docs){ await deleteDoc(d.ref); n++; }
    console.log("Cleared", n, "games for", state.weekId);
    toast("Cleared " + n + "games");
    computeWeekStandings();
  }

  // Seeder (kept)
  async function seedWeek1(items){
    if (!state.isAdmin){ console.warn("Admin only"); return; }
    const col = collection(db, "weeks", state.weekId, "games");
    let n=0;
    for (const item of items){
      const day = item.day || "Sunday";
      const home = item.home?.trim(); const away = item.away?.trim();
      const kickoffTs = item.kickoff ? Date.parse(item.kickoff) : (typeof item.kickoffTs==="number" ? item.kickoffTs : null);
      if (!home || !away) continue;
      await addDoc(col, { day, home, away, createdAt: Date.now(), ...(kickoffTs ? { kickoffTs } : {}) });
      n++;
    }
    console.log("Seeded", n, "games into", state.weekId);
    computeWeekStandings();
  }

  // --- Standings (Week + Publish + Overall helper) ---
  function wireStandingsButtons(){
    el("#publishWrap").style.display = state.isAdmin ? "" : "none";
    el("#recalcBtn")?.addEventListener("click", computeWeekStandings);
    el("#publishBtn")?.addEventListener("click", publishWeekStandings);
  }

  async function computeWeekStandings(){
    try{
      // Winners for THIS week
      const gamesSnap = await getDocs(collection(db, "weeks", state.weekId, "games"));
      const winners = {};
      let totalGames = 0;
      gamesSnap.forEach(d => {
        const g = d.data();
        if (g.winner === "home" || g.winner === "away") {
          winners[d.id] = g.winner;
          totalGames++;
        }
      });

      // All picks docs (filter client-side to avoid Firestore index requirement)
      const picksSnap = await getDocs(collectionGroup(db, "weeks"));

      // Aggregate by email (dedupe)
      const rowsByEmail = new Map(); // emailLower -> { email, wins, played, uid, name }
      picksSnap.forEach(docSnap => {
        const data = docSnap.data();
        if (data.weekId !== state.weekId) return;
        const email = (data.email || "").trim();
        if (!email) return;
        const uid = docSnap.ref.path.split("/")[1];
        const name = data.userName || data.name || data.displayName;

        const picks = data.picks || {};
        let wins = 0, played = 0;

        for (const [gameId, side] of Object.entries(picks)) {
          const w = winners[gameId];
          if (!w) continue;
          played++;
          if (w === side) wins++;
        }

        const key = email.toLowerCase();
        const curr = rowsByEmail.get(key);
        if (!curr) {
          rowsByEmail.set(key, { email, wins, played, uid, name });
        } else {
          curr.wins += wins;
          curr.played += played;
          if (!curr.uid) curr.uid = uid;
          if (!curr.name && name) curr.name = name;
        }
      });

      const rows = Array.from(rowsByEmail.values());
      await enrichStandingsNames(rows);
      rows.sort((a,b) => b.wins - a.wins || a.email.localeCompare(b.email));
      renderStandingsTable(rows, totalGames);
    }catch(e){
      console.error("standings error", e);
      el("#standingsBody").innerHTML = `<div class="muted">Unable to compute standings (${e.message}).</div>`;
    }
  }

  async function enrichStandingsNames(rows){
    const missing = rows.filter(r => !r.name && r.uid).map(r => r.uid);
    await Promise.all(missing.map(async uid => {
      try {
        const snap = await getDoc(doc(db, "publicUsers", uid));
        if (snap.exists()){
          const target = rows.find(r => r.uid === uid);
          const data = snap.data() || {};
          target.name = data.displayName || data.name || data.userName || target.email;
        }
      } catch {}
    }));
  }

  function renderStandingsTable(rows, totalGames){
    if (!rows.length){
      el("#standingsBody").innerHTML = `<div class="muted">No data yet.</div>`;
      return;
    }

    const myEmail = state.user?.email || "";
    const maxWins = Math.max(...rows.map(r => r.wins));
    const pct = (w, t) => t ? (w/t*100).toFixed(1)+"%" : "‚Äî";

    const html = [
      `<table class="standings-table"><thead><tr>
        <th>Rank</th><th>User</th><th>Wins</th><th>Played</th><th>Win %</th>
      </tr></thead><tbody>`
    ];

    rows.forEach((r, i) => {
      const isLeader = r.wins === maxWins && r.played > 0;
      const isMe = r.email === myEmail;
      const isPerfect = r.played > 0 && r.wins === r.played;
      const isSub500 = r.played > 0 && (r.wins / r.played) < 0.5;

      const rowClasses = [
        isLeader ? "leader" : "",
        isMe ? "me" : "",
        isPerfect ? "perfect" : "",
        isSub500 ? "sub500" : ""
      ].filter(Boolean).join(" ");

      const chips = [
        isLeader ? `<span class="badge-chip leader">ü•á Leader</span>` : "",
        isMe ? `<span class="badge-chip me">‚≠ê You</span>` : "",
        isPerfect ? `<span class="badge-chip perfect">üèÜ Perfect</span>` : "",
        isSub500 ? `<span class="badge-chip sub500">‚Üò Sub-.500</span>` : ""
      ].join("");

      html.push(
        `<tr class="${rowClasses}">
          <td>${i+1}</td>
          <td>${(r.name || r.email)}${chips}</td>
          <td>${r.wins}</td>
          <td>${r.played}/${totalGames}</td>
          <td>${pct(r.wins, r.played)}</td>
        </tr>`
      );
    });

    html.push(`</tbody></table>`);
    el("#standingsBody").innerHTML = html.join("");
  }

  async function publishWeekStandings(){
    if (!state.isAdmin) return;
    const gamesSnap = await getDocs(collection(db, "weeks", state.weekId, "games"));
    const winners = {}; gamesSnap.forEach(d => { const g=d.data(); if (g.winner) winners[d.id]=g.winner; });

    const cg = await getDocs(collectionGroup(db, "weeks"));
    const batch = [];
    for (const docSnap of cg.docs){
      const data = docSnap.data(); if (data.weekId !== state.weekId) continue;
      const picks = data.picks || {}; const email = data.email || docSnap.ref.path.split("/")[1];
      let wins=0; for (const [gid,side] of Object.entries(picks)){ if (winners[gid] && winners[gid]===side) wins++; }
      const uid = docSnap.ref.path.split("/")[1];
      const ref = doc(db, "leaderboards", "weeks", state.weekId, "scores", uid);
      batch.push(setDoc(ref, { email, wins, weekId: state.weekId, updatedAt: Date.now() }, { merge:true }));
    }
    await Promise.all(batch);
    toast("Week standings published");
  }

  // Expose for console debugging
  window.appState = state;
  window.db = db;
</script>

</body>
</html>
